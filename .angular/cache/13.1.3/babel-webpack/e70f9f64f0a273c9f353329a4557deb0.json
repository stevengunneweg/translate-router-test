{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Inject, Pipe, PLATFORM_ID, NgModuleFactory, ApplicationRef, Injector, Compiler, Optional, SkipSelf, APP_INITIALIZER, NgModule } from '@angular/core';\nimport * as i3 from '@angular/router';\nimport { NavigationStart, NavigationCancel, Router, ActivatedRoute, ROUTES, UrlSerializer, ChildrenOutletContexts, ROUTER_CONFIGURATION, UrlHandlingStrategy, RouteReuseStrategy, RouterModule } from '@angular/router';\nimport { Observable, Subject, ReplaySubject, of, from, isObservable } from 'rxjs';\nimport { filter, pairwise, mergeMap, map } from 'rxjs/operators';\nimport * as i1 from '@ngx-translate/core';\nimport { TranslateService, TranslateModule } from '@ngx-translate/core';\nimport * as i2 from '@angular/common';\nimport { Location, isPlatformBrowser, CommonModule } from '@angular/common';\nimport { HttpParams } from '@angular/common/http';\n/**\n * Guard to make sure we have single initialization of forRoot\n */\n\nconst LOCALIZE_ROUTER_FORROOT_GUARD = new InjectionToken('LOCALIZE_ROUTER_FORROOT_GUARD');\n/**\n * Static provider for keeping track of routes\n */\n\nconst RAW_ROUTES = new InjectionToken('RAW_ROUTES');\n/**\n * Type for Caching of default language\n */\n// export type CacheMechanism = 'LocalStorage' | 'Cookie';\n\n/**\n * Namespace for fail proof access of CacheMechanism\n */\n\nvar CacheMechanism;\n\n(function (CacheMechanism) {\n  CacheMechanism[\"LocalStorage\"] = \"LocalStorage\";\n  CacheMechanism[\"SessionStorage\"] = \"SessionStorage\";\n  CacheMechanism[\"Cookie\"] = \"Cookie\";\n})(CacheMechanism || (CacheMechanism = {}));\n/**\n * Boolean to indicate whether to use cached language value\n */\n\n\nconst USE_CACHED_LANG = new InjectionToken('USE_CACHED_LANG');\n/**\n * Cache mechanism type\n */\n\nconst CACHE_MECHANISM = new InjectionToken('CACHE_MECHANISM');\n/**\n * Cache name\n */\n\nconst CACHE_NAME = new InjectionToken('CACHE_NAME');\n/**\n * Cookie cache format\n */\n\nconst COOKIE_FORMAT = new InjectionToken('COOKIE_FORMAT');\n/**\n * Cookie cache format\n */\n\nconst INITIAL_NAVIGATION = new InjectionToken('INITIAL_NAVIGATION');\n/**\n * Function for calculating default language\n */\n\nconst DEFAULT_LANG_FUNCTION = new InjectionToken('DEFAULT_LANG_FUNCTION');\n/**\n * Boolean to indicate whether prefix should be set for single language scenarios\n */\n\nconst ALWAYS_SET_PREFIX = new InjectionToken('ALWAYS_SET_PREFIX');\nconst LOCALIZE_CACHE_NAME = 'LOCALIZE_DEFAULT_LANGUAGE';\nconst DEFAULT_COOKIE_FORMAT = '{{value}};{{expires}}';\nconst DEFAULT_INITIAL_NAVIGATION = false;\n\nclass LocalizeRouterSettings {\n  /**\n   * Settings for localize router\n   */\n  constructor(useCachedLang = true, alwaysSetPrefix = true, cacheMechanism = CacheMechanism.LocalStorage, cacheName = LOCALIZE_CACHE_NAME, defaultLangFunction = void 0, cookieFormat = DEFAULT_COOKIE_FORMAT, initialNavigation = DEFAULT_INITIAL_NAVIGATION) {\n    this.useCachedLang = useCachedLang;\n    this.alwaysSetPrefix = alwaysSetPrefix;\n    this.cacheName = cacheName;\n    this.cookieFormat = cookieFormat;\n    this.initialNavigation = initialNavigation;\n    this.cacheMechanism = cacheMechanism;\n    this.defaultLangFunction = defaultLangFunction;\n  }\n\n}\n\nLocalizeRouterSettings.ɵfac = function LocalizeRouterSettings_Factory(t) {\n  return new (t || LocalizeRouterSettings)(i0.ɵɵinject(USE_CACHED_LANG), i0.ɵɵinject(ALWAYS_SET_PREFIX), i0.ɵɵinject(CACHE_MECHANISM), i0.ɵɵinject(CACHE_NAME), i0.ɵɵinject(DEFAULT_LANG_FUNCTION), i0.ɵɵinject(COOKIE_FORMAT), i0.ɵɵinject(INITIAL_NAVIGATION));\n};\n\nLocalizeRouterSettings.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: LocalizeRouterSettings,\n  factory: LocalizeRouterSettings.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LocalizeRouterSettings, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [USE_CACHED_LANG]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [ALWAYS_SET_PREFIX]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [CACHE_MECHANISM]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [CACHE_NAME]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [DEFAULT_LANG_FUNCTION]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [COOKIE_FORMAT]\n      }]\n    }, {\n      type: undefined,\n      decorators: [{\n        type: Inject,\n        args: [INITIAL_NAVIGATION]\n      }]\n    }];\n  }, null);\n})();\n\nconst COOKIE_EXPIRY = 30; // 1 month\n\n/**\n * Abstract class for parsing localization\n */\n\nclass LocalizeParser {\n  /**\n   * Loader constructor\n   */\n  constructor(translate, location, settings) {\n    this.translate = translate;\n    this.location = location;\n    this.settings = settings;\n  }\n  /**\n  * Prepare routes to be fully usable by ngx-translate-router\n  * @param routes\n  */\n\n  /* private initRoutes(routes: Routes, prefix = '') {\n    routes.forEach(route => {\n      if (route.path !== '**') {\n        const routeData: any = route.data = route.data || {};\n        routeData.localizeRouter = {};\n        routeData.localizeRouter.fullPath = `${prefix}/${route.path}`;\n        if (route.children && route.children.length > 0) {\n          this.initRoutes(route.children, routeData.localizeRouter.fullPath);\n        }\n      }\n    });\n  } */\n\n  /**\n   * Initialize language and routes\n   */\n\n\n  init(routes) {\n    let selectedLanguage; // this.initRoutes(routes);\n\n    this.routes = routes;\n\n    if (!this.locales || !this.locales.length) {\n      return Promise.resolve();\n    }\n    /** detect current language */\n\n\n    const locationLang = this.getLocationLang();\n\n    const browserLang = this._getBrowserLang();\n\n    if (this.settings.defaultLangFunction) {\n      this.defaultLang = this.settings.defaultLangFunction(this.locales, this._cachedLang, browserLang);\n    } else {\n      this.defaultLang = this._cachedLang || browserLang || this.locales[0];\n    }\n\n    selectedLanguage = locationLang || this.defaultLang;\n    this.translate.setDefaultLang(this.defaultLang);\n    let children = [];\n    /** if set prefix is enforced */\n\n    if (this.settings.alwaysSetPrefix) {\n      const baseRoute = {\n        path: '',\n        redirectTo: this.defaultLang,\n        pathMatch: 'full'\n      };\n      /** extract potential wildcard route */\n\n      const wildcardIndex = routes.findIndex(route => route.path === '**');\n\n      if (wildcardIndex !== -1) {\n        this._wildcardRoute = routes.splice(wildcardIndex, 1)[0];\n      }\n\n      children = this.routes.splice(0, this.routes.length, baseRoute);\n    } else {\n      children = [...this.routes]; // shallow copy of routes\n    }\n    /** exclude certain routes */\n\n\n    for (let i = children.length - 1; i >= 0; i--) {\n      if (children[i].data && children[i].data['skipRouteLocalization']) {\n        if (this.settings.alwaysSetPrefix) {\n          // add directly to routes\n          this.routes.push(children[i]);\n        } // remove from routes to translate only if doesn't have to translate `redirectTo` property\n\n\n        if (children[i].redirectTo === undefined || !children[i].data['skipRouteLocalization']['localizeRedirectTo']) {\n          children.splice(i, 1);\n        }\n      }\n    }\n    /** append children routes */\n\n\n    if (children && children.length) {\n      if (this.locales.length > 1 || this.settings.alwaysSetPrefix) {\n        this._languageRoute = {\n          children: children\n        };\n        this.routes.unshift(this._languageRoute);\n      }\n    }\n    /** ...and potential wildcard route */\n\n\n    if (this._wildcardRoute && this.settings.alwaysSetPrefix) {\n      this.routes.push(this._wildcardRoute);\n    }\n    /** translate routes */\n\n\n    const res = this.translateRoutes(selectedLanguage);\n    return res.toPromise();\n  }\n\n  initChildRoutes(routes) {\n    this._translateRouteTree(routes);\n\n    return routes;\n  }\n  /**\n   * Translate routes to selected language\n   */\n\n\n  translateRoutes(language) {\n    return new Observable(observer => {\n      this._cachedLang = language;\n\n      if (this._languageRoute) {\n        this._languageRoute.path = language;\n      }\n\n      this.translate.use(language).subscribe(translations => {\n        this._translationObject = translations;\n        this.currentLang = language;\n\n        if (this._languageRoute) {\n          if (this._languageRoute) {\n            this._translateRouteTree(this._languageRoute.children);\n          } // if there is wildcard route\n\n\n          if (this._wildcardRoute && this._wildcardRoute.redirectTo) {\n            this._translateProperty(this._wildcardRoute, 'redirectTo', true);\n          }\n        } else {\n          this._translateRouteTree(this.routes);\n        }\n\n        observer.next(void 0);\n        observer.complete();\n      });\n    });\n  }\n  /**\n   * Translate the route node and recursively call for all it's children\n   */\n\n\n  _translateRouteTree(routes) {\n    routes.forEach(route => {\n      const skipRouteLocalization = route.data && route.data['skipRouteLocalization'];\n      const localizeRedirection = !skipRouteLocalization || skipRouteLocalization['localizeRedirectTo'];\n\n      if (route.redirectTo && localizeRedirection) {\n        this._translateProperty(route, 'redirectTo', !route.redirectTo.indexOf('/'));\n      }\n\n      if (!skipRouteLocalization) {\n        if (route.path !== null && route.path !== undefined\n        /* && route.path !== '**'*/\n        ) {\n          this._translateProperty(route, 'path');\n        }\n\n        if (route.children) {\n          this._translateRouteTree(route.children);\n        }\n\n        if (route.loadChildren && route._loadedConfig) {\n          this._translateRouteTree(route._loadedConfig.routes);\n        }\n      }\n    });\n  }\n  /**\n   * Translate property\n   * If first time translation then add original to route data object\n   */\n\n\n  _translateProperty(route, property, prefixLang) {\n    // set property to data if not there yet\n    const routeData = route.data = route.data || {};\n\n    if (!routeData.localizeRouter) {\n      routeData.localizeRouter = {};\n    }\n\n    if (!routeData.localizeRouter[property]) {\n      routeData.localizeRouter = Object.assign(Object.assign({}, routeData.localizeRouter), {\n        [property]: route[property]\n      });\n    }\n\n    const result = this.translateRoute(routeData.localizeRouter[property]);\n    route[property] = prefixLang ? this.addPrefixToUrl(result) : result;\n  }\n\n  get urlPrefix() {\n    if (this.settings.alwaysSetPrefix || this.currentLang !== this.defaultLang) {\n      return this.currentLang ? this.currentLang : this.defaultLang;\n    } else {\n      return '';\n    }\n  }\n  /**\n   * Add current lang as prefix to given url.\n   */\n\n\n  addPrefixToUrl(url) {\n    const plitedUrl = url.split('?');\n    plitedUrl[0] = plitedUrl[0].replace(/\\/$/, '');\n    return `/${this.urlPrefix}${plitedUrl.join('?')}`;\n  }\n  /**\n   * Translate route and return observable\n   */\n\n\n  translateRoute(path) {\n    const queryParts = path.split('?');\n\n    if (queryParts.length > 2) {\n      throw Error('There should be only one query parameter block in the URL');\n    }\n\n    const pathSegments = queryParts[0].split('/');\n    /** collect observables  */\n\n    return pathSegments.map(part => part.length ? this.translateText(part) : part).join('/') + (queryParts.length > 1 ? `?${queryParts[1]}` : '');\n  }\n  /**\n   * Get language from url\n   */\n\n\n  getLocationLang(url) {\n    const queryParamSplit = (url || this.location.path()).split(/[\\?;]/);\n    let pathSlices = [];\n\n    if (queryParamSplit.length > 0) {\n      pathSlices = queryParamSplit[0].split('/');\n    }\n\n    if (pathSlices.length > 1 && this.locales.indexOf(pathSlices[1]) !== -1) {\n      return pathSlices[1];\n    }\n\n    if (pathSlices.length && this.locales.indexOf(pathSlices[0]) !== -1) {\n      return pathSlices[0];\n    }\n\n    return null;\n  }\n  /**\n   * Get user's language set in the browser\n   */\n\n\n  _getBrowserLang() {\n    return this._returnIfInLocales(this.translate.getBrowserLang());\n  }\n  /**\n   * Get language from local storage or cookie\n   */\n\n\n  get _cachedLang() {\n    if (!this.settings.useCachedLang) {\n      return;\n    }\n\n    if (this.settings.cacheMechanism === CacheMechanism.LocalStorage) {\n      return this._cacheWithLocalStorage();\n    }\n\n    if (this.settings.cacheMechanism === CacheMechanism.SessionStorage) {\n      return this._cacheWithSessionStorage();\n    }\n\n    if (this.settings.cacheMechanism === CacheMechanism.Cookie) {\n      return this._cacheWithCookies();\n    }\n  }\n  /**\n   * Save language to local storage or cookie\n   */\n\n\n  set _cachedLang(value) {\n    if (!this.settings.useCachedLang) {\n      return;\n    }\n\n    if (this.settings.cacheMechanism === CacheMechanism.LocalStorage) {\n      this._cacheWithLocalStorage(value);\n    }\n\n    if (this.settings.cacheMechanism === CacheMechanism.SessionStorage) {\n      this._cacheWithSessionStorage(value);\n    }\n\n    if (this.settings.cacheMechanism === CacheMechanism.Cookie) {\n      this._cacheWithCookies(value);\n    }\n  }\n  /**\n   * Cache value to local storage\n   */\n\n\n  _cacheWithLocalStorage(value) {\n    try {\n      if (typeof window === 'undefined' || typeof window.localStorage === 'undefined') {\n        return;\n      }\n\n      if (value) {\n        window.localStorage.setItem(this.settings.cacheName, value);\n        return;\n      }\n\n      return this._returnIfInLocales(window.localStorage.getItem(this.settings.cacheName));\n    } catch (e) {\n      // weird Safari issue in private mode, where LocalStorage is defined but throws error on access\n      return;\n    }\n  }\n  /**\n   * Cache value to session storage\n   */\n\n\n  _cacheWithSessionStorage(value) {\n    try {\n      if (typeof window === 'undefined' || typeof window.sessionStorage === 'undefined') {\n        return;\n      }\n\n      if (value) {\n        window.sessionStorage.setItem(this.settings.cacheName, value);\n        return;\n      }\n\n      return this._returnIfInLocales(window.sessionStorage.getItem(this.settings.cacheName));\n    } catch (e) {\n      return;\n    }\n  }\n  /**\n   * Cache value via cookies\n   */\n\n\n  _cacheWithCookies(value) {\n    try {\n      if (typeof document === 'undefined' || typeof document.cookie === 'undefined') {\n        return;\n      }\n\n      const name = encodeURIComponent(this.settings.cacheName);\n\n      if (value) {\n        let cookieTemplate = `${this.settings.cookieFormat}`;\n        cookieTemplate = cookieTemplate.replace('{{value}}', `${name}=${encodeURIComponent(value)}`).replace(/{{expires:?(\\d+)?}}/g, (fullMatch, groupMatch) => {\n          const days = groupMatch === undefined ? COOKIE_EXPIRY : parseInt(groupMatch, 10);\n          const date = new Date();\n          date.setTime(date.getTime() + days * 86400000);\n          return `expires=${date.toUTCString()}`;\n        });\n        document.cookie = cookieTemplate;\n        return;\n      }\n\n      const regexp = new RegExp('(?:^' + name + '|;\\\\s*' + name + ')=(.*?)(?:;|$)', 'g');\n      const result = regexp.exec(document.cookie);\n      return decodeURIComponent(result[1]);\n    } catch (e) {\n      return; // should not happen but better safe than sorry (can happen by using domino)\n    }\n  }\n  /**\n   * Check if value exists in locales list\n   */\n\n\n  _returnIfInLocales(value) {\n    if (value && this.locales.indexOf(value) !== -1) {\n      return value;\n    }\n\n    return null;\n  }\n  /**\n   * Get translated value\n   */\n\n\n  translateText(key) {\n    if (this.escapePrefix && key.startsWith(this.escapePrefix)) {\n      return key.replace(this.escapePrefix, '');\n    } else {\n      if (!this._translationObject) {\n        return key;\n      }\n\n      const fullKey = this.prefix + key;\n      const res = this.translate.getParsedResult(this._translationObject, fullKey);\n      return res !== fullKey ? res : key;\n    }\n  }\n  /**\n   * Strategy to choose between new or old queryParams\n   * @param newExtras extras that containes new QueryParams\n   * @param currentQueryParams current query params\n   */\n\n\n  chooseQueryParams(newExtras, currentQueryParams) {\n    let queryParamsObj;\n\n    if (newExtras && newExtras.queryParams) {\n      queryParamsObj = newExtras.queryParams;\n    } else if (currentQueryParams) {\n      queryParamsObj = currentQueryParams;\n    }\n\n    return queryParamsObj;\n  }\n  /**\n   * Format query params from object to string.\n   * Exemple of result: `param=value&param2=value2`\n   * @param params query params object\n   */\n\n\n  formatQueryParams(params) {\n    return new HttpParams({\n      fromObject: params\n    }).toString();\n  }\n  /**\n   * Get translation key prefix from config\n   */\n\n\n  getPrefix() {\n    return this.prefix;\n  }\n  /**\n   * Get escape translation prefix from config\n   */\n\n\n  getEscapePrefix() {\n    return this.escapePrefix;\n  }\n\n}\n\nLocalizeParser.ɵfac = function LocalizeParser_Factory(t) {\n  return new (t || LocalizeParser)(i0.ɵɵinject(TranslateService), i0.ɵɵinject(Location), i0.ɵɵinject(LocalizeRouterSettings));\n};\n\nLocalizeParser.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: LocalizeParser,\n  factory: LocalizeParser.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LocalizeParser, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: i1.TranslateService,\n      decorators: [{\n        type: Inject,\n        args: [TranslateService]\n      }]\n    }, {\n      type: i2.Location,\n      decorators: [{\n        type: Inject,\n        args: [Location]\n      }]\n    }, {\n      type: LocalizeRouterSettings,\n      decorators: [{\n        type: Inject,\n        args: [LocalizeRouterSettings]\n      }]\n    }];\n  }, null);\n})();\n/**\n * Manually set configuration\n */\n\n\nclass ManualParserLoader extends LocalizeParser {\n  /**\n   * CTOR\n   */\n  constructor(translate, location, settings, locales = ['en'], prefix = 'ROUTES.', escapePrefix = '') {\n    super(translate, location, settings);\n    this.locales = locales;\n    this.prefix = prefix || '';\n    this.escapePrefix = escapePrefix || '';\n  }\n  /**\n   * Initialize or append routes\n   */\n\n\n  load(routes) {\n    return new Promise(resolve => {\n      this.init(routes).then(resolve);\n    });\n  }\n\n}\n\nclass DummyLocalizeParser extends LocalizeParser {\n  load(routes) {\n    return new Promise(resolve => {\n      this.init(routes).then(resolve);\n    });\n  }\n\n}\n\nDummyLocalizeParser.ɵfac = /* @__PURE__ */function () {\n  let ɵDummyLocalizeParser_BaseFactory;\n  return function DummyLocalizeParser_Factory(t) {\n    return (ɵDummyLocalizeParser_BaseFactory || (ɵDummyLocalizeParser_BaseFactory = i0.ɵɵgetInheritedFactory(DummyLocalizeParser)))(t || DummyLocalizeParser);\n  };\n}();\n\nDummyLocalizeParser.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: DummyLocalizeParser,\n  factory: DummyLocalizeParser.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(DummyLocalizeParser, [{\n    type: Injectable\n  }], null, null);\n})();\n/**\n * Compare if two objects are same\n */\n\n\nfunction equals(o1, o2) {\n  if (o1 === o2) {\n    return true;\n  }\n\n  if (o1 === null || o2 === null) {\n    return false;\n  }\n\n  if (o1 !== o1 && o2 !== o2) {\n    return true; // NaN === NaN\n  }\n\n  const t1 = typeof o1,\n        t2 = typeof o2;\n  let length, key, keySet;\n\n  if (t1 === t2 && t1 === 'object') {\n    if (Array.isArray(o1)) {\n      if (!Array.isArray(o2)) {\n        return false;\n      }\n\n      if ((length = o1.length) === o2.length) {\n        for (key = 0; key < length; key++) {\n          if (!equals(o1[key], o2[key])) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n    } else {\n      if (Array.isArray(o2)) {\n        return false;\n      }\n\n      keySet = Object.create(null);\n\n      for (key in o1) {\n        if (o1.hasOwnProperty(key)) {\n          if (!equals(o1[key], o2[key])) {\n            return false;\n          }\n\n          keySet[key] = true;\n        }\n      }\n\n      for (key in o2) {\n        if (o2.hasOwnProperty(key)) {\n          if (!(key in keySet) && typeof o2[key] !== 'undefined') {\n            return false;\n          }\n        }\n      }\n\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * Determine if the argument is shaped like a Promise\n */\n\n\nfunction isPromise(obj) {\n  // allow any Promise/A+ compliant thenable.\n  // It's up to the caller to ensure that obj.then conforms to the spec\n  return !!obj && typeof obj.then === 'function';\n}\n/**\n * Deep copy of object and array\n */\n\n\nfunction deepCopy(object) {\n  const output = Array.isArray(object) ? [] : {};\n\n  for (const data in object) {\n    if (data) {\n      const value = object[data];\n      output[data] = typeof value === 'object' ? deepCopy(value) : value;\n    }\n  }\n\n  return output;\n}\n\nfunction flatten(list) {\n  return list.reduce((flat, item) => {\n    const flatItem = Array.isArray(item) ? flatten(item) : item;\n    return flat.concat(flatItem);\n  }, []);\n}\n/**\n * Localization service\n * modifyRoutes\n */\n\n\nclass LocalizeRouterService {\n  /**\n   * CTOR\n   */\n  constructor(parser, settings, router, route\n  /*,\n  @Inject(Location) private location: Location*/\n  ) {\n    this.parser = parser;\n    this.settings = settings;\n    this.router = router;\n    this.route = route;\n    this.routerEvents = new Subject();\n    const initializedSubject = new ReplaySubject(1);\n    this.hooks = {\n      _initializedSubject: initializedSubject,\n      initialized: initializedSubject.asObservable()\n    };\n  }\n  /**\n   * Start up the service\n   */\n\n\n  init() {\n    this.applyConfigToRouter(this.parser.routes); // subscribe to router events\n\n    this.router.events.pipe(filter(event => event instanceof NavigationStart), pairwise()).subscribe(this._routeChanged());\n\n    if (this.settings.initialNavigation) {\n      this.router.initialNavigation();\n    }\n  }\n  /**\n   * Change language and navigate to translated route\n   */\n\n\n  changeLanguage(lang, extras, useNavigateMethod) {\n    if (lang !== this.parser.currentLang) {\n      const rootSnapshot = this.router.routerState.snapshot.root;\n      this.parser.translateRoutes(lang).subscribe(() => {\n        let url = this.traverseRouteSnapshot(rootSnapshot);\n        url = this.translateRoute(url);\n\n        if (!this.settings.alwaysSetPrefix) {\n          let urlSegments = url.split('/');\n          const languageSegmentIndex = urlSegments.indexOf(this.parser.currentLang); // If the default language has no prefix make sure to remove and add it when necessary\n\n          if (this.parser.currentLang === this.parser.defaultLang) {\n            // Remove the language prefix from url when current language is the default language\n            if (languageSegmentIndex === 0 || languageSegmentIndex === 1 && urlSegments[0] === '') {\n              // Remove the current aka default language prefix from the url\n              urlSegments = urlSegments.slice(0, languageSegmentIndex).concat(urlSegments.slice(languageSegmentIndex + 1));\n            }\n          } else {\n            // When coming from a default language it's possible that the url doesn't contain the language, make sure it does.\n            if (languageSegmentIndex === -1) {\n              // If the url starts with a slash make sure to keep it.\n              const injectionIndex = urlSegments[0] === '' ? 1 : 0;\n              urlSegments = urlSegments.slice(0, injectionIndex).concat(this.parser.currentLang, urlSegments.slice(injectionIndex));\n            }\n          }\n\n          url = urlSegments.join('/');\n        } // Prevent multiple \"/\" character\n\n\n        url = url.replace(/\\/+/g, '/');\n        const lastSlashIndex = url.lastIndexOf('/');\n\n        if (lastSlashIndex > 0 && lastSlashIndex === url.length - 1) {\n          url = url.slice(0, -1);\n        }\n\n        const queryParamsObj = this.parser.chooseQueryParams(extras, this.route.snapshot.queryParams);\n        this.applyConfigToRouter(this.parser.routes);\n        this.lastExtras = extras;\n\n        if (useNavigateMethod) {\n          const extrasToApply = extras ? Object.assign({}, extras) : {};\n\n          if (queryParamsObj) {\n            extrasToApply.queryParams = queryParamsObj;\n          }\n\n          this.router.navigate([url], extrasToApply);\n        } else {\n          let queryParams = this.parser.formatQueryParams(queryParamsObj);\n          queryParams = queryParams ? `?${queryParams}` : '';\n          this.router.navigateByUrl(`${url}${queryParams}`, extras);\n        }\n      });\n    }\n  }\n  /**\n   * Traverses through the tree to assemble new translated url\n   */\n\n\n  traverseRouteSnapshot(snapshot) {\n    if (snapshot.firstChild && snapshot.routeConfig) {\n      return `${this.parseSegmentValue(snapshot)}/${this.traverseRouteSnapshot(snapshot.firstChild)}`;\n    } else if (snapshot.firstChild) {\n      return this.traverseRouteSnapshot(snapshot.firstChild);\n    } else {\n      return this.parseSegmentValue(snapshot);\n    }\n    /* if (snapshot.firstChild && snapshot.firstChild.routeConfig && snapshot.firstChild.routeConfig.path) {\n      if (snapshot.firstChild.routeConfig.path !== '**') {\n        return this.parseSegmentValue(snapshot) + '/' + this.traverseRouteSnapshot(snapshot.firstChild);\n      } else {\n        return this.parseSegmentValue(snapshot.firstChild);\n      }\n    }\n    return this.parseSegmentValue(snapshot); */\n\n  }\n  /**\n   * Build URL from segments and snapshot (for params)\n   */\n\n\n  buildUrlFromSegments(snapshot, segments) {\n    return segments.map((s, i) => s.indexOf(':') === 0 ? snapshot.url[i].path : s).join('/');\n  }\n  /**\n   * Extracts new segment value based on routeConfig and url\n   */\n\n\n  parseSegmentValue(snapshot) {\n    if (snapshot.routeConfig && snapshot.routeConfig.matcher) {\n      const subPathMatchedSegments = this.parseSegmentValueMatcher(snapshot);\n      return this.buildUrlFromSegments(snapshot, subPathMatchedSegments);\n    } else if (snapshot.data.localizeRouter) {\n      const path = snapshot.data.localizeRouter.path;\n      const subPathSegments = path.split('/');\n      return this.buildUrlFromSegments(snapshot, subPathSegments);\n    } else if (snapshot.parent && snapshot.parent.parent) {\n      // Not lang route and no localizeRouter data = excluded path\n      const path = snapshot.routeConfig.path;\n      const subPathSegments = path.split('/');\n      return this.buildUrlFromSegments(snapshot, subPathSegments);\n    } else {\n      return '';\n    }\n    /* if (snapshot.routeConfig) {\n      if (snapshot.routeConfig.path === '**') {\n        return snapshot.url.filter((segment: UrlSegment) => segment.path).map((segment: UrlSegment) => segment.path).join('/');\n      } else {\n        const subPathSegments = snapshot.routeConfig.path.split('/');\n        return subPathSegments.map((s: string, i: number) => s.indexOf(':') === 0 ? snapshot.url[i].path : s).join('/');\n      }\n    }\n    return ''; */\n\n  }\n\n  parseSegmentValueMatcher(snapshot) {\n    const localizeMatcherParams = snapshot.data && snapshot.data.localizeMatcher && snapshot.data.localizeMatcher.params || {};\n    const subPathSegments = snapshot.url.map(segment => {\n      const currentPath = segment.path;\n      const matchedParamName = segment.localizedParamName;\n      const val = matchedParamName && localizeMatcherParams[matchedParamName] ? localizeMatcherParams[matchedParamName](currentPath) : null;\n      return val || `${this.parser.getEscapePrefix()}${currentPath}`;\n    });\n    return subPathSegments;\n  }\n  /**\n   * Translate route to current language\n   * If new language is explicitly provided then replace language part in url with new language\n   */\n\n\n  translateRoute(path) {\n    if (typeof path === 'string') {\n      const url = this.parser.translateRoute(path);\n      return !path.indexOf('/') ? this.parser.addPrefixToUrl(url) : url;\n    } // it's an array\n\n\n    const result = [];\n    path.forEach((segment, index) => {\n      if (typeof segment === 'string') {\n        const res = this.parser.translateRoute(segment);\n\n        if (!index && !segment.indexOf('/')) {\n          result.push(this.parser.addPrefixToUrl(res));\n        } else {\n          result.push(res);\n        }\n      } else {\n        result.push(segment);\n      }\n    });\n    return result;\n  }\n  /**\n   * Event handler to react on route change\n   */\n\n\n  _routeChanged() {\n    return ([previousEvent, currentEvent]) => {\n      const previousLang = this.parser.getLocationLang(previousEvent.url) || this.parser.defaultLang;\n      const currentLang = this.parser.getLocationLang(currentEvent.url) || this.parser.defaultLang;\n      const lastExtras = this.lastExtras;\n\n      if (currentLang !== previousLang && this.latestUrl !== currentEvent.url) {\n        this.latestUrl = currentEvent.url;\n        this.cancelCurrentNavigation();\n        this.parser.translateRoutes(currentLang).subscribe(() => {\n          // Reset routes again once they are all translated\n          this.applyConfigToRouter(this.parser.routes); // Clear global extras\n\n          this.lastExtras = undefined; // Init new navigation with same url to take new congif in consideration\n\n          this.router.navigateByUrl(currentEvent.url, lastExtras); // Fire route change event\n\n          this.routerEvents.next(currentLang);\n        });\n      }\n\n      this.latestUrl = currentEvent.url;\n    };\n  }\n  /**\n   * Drop the current Navigation\n   */\n\n\n  cancelCurrentNavigation() {\n    const currentNavigation = this.router.getCurrentNavigation();\n    const url = this.router.serializeUrl(currentNavigation.extractedUrl);\n    this.router.events.next(new NavigationCancel(currentNavigation.id, url, ''));\n    this.router.transitions.next(Object.assign(Object.assign({}, this.router.transitions.getValue()), {\n      id: 0\n    }));\n  }\n  /**\n   * Apply config to Angular RouterModule\n   * @param config routes to apply\n   */\n\n\n  applyConfigToRouter(config) {\n    this.router.resetConfig(deepCopy(config));\n  }\n\n}\n\nLocalizeRouterService.ɵfac = function LocalizeRouterService_Factory(t) {\n  return new (t || LocalizeRouterService)(i0.ɵɵinject(LocalizeParser), i0.ɵɵinject(LocalizeRouterSettings), i0.ɵɵinject(Router), i0.ɵɵinject(ActivatedRoute));\n};\n\nLocalizeRouterService.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: LocalizeRouterService,\n  factory: LocalizeRouterService.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LocalizeRouterService, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: LocalizeParser,\n      decorators: [{\n        type: Inject,\n        args: [LocalizeParser]\n      }]\n    }, {\n      type: LocalizeRouterSettings,\n      decorators: [{\n        type: Inject,\n        args: [LocalizeRouterSettings]\n      }]\n    }, {\n      type: i3.Router,\n      decorators: [{\n        type: Inject,\n        args: [Router]\n      }]\n    }, {\n      type: i3.ActivatedRoute,\n      decorators: [{\n        type: Inject,\n        args: [ActivatedRoute]\n      }]\n    }];\n  }, null);\n})();\n\nconst VIEW_DESTROYED_STATE = 128;\n\nclass LocalizeRouterPipe {\n  /**\n   * CTOR\n   */\n  constructor(localize, _ref) {\n    this.localize = localize;\n    this._ref = _ref;\n    this.value = '';\n    this.subscription = this.localize.routerEvents.subscribe(() => {\n      this.transform(this.lastKey);\n    });\n  }\n\n  ngOnDestroy() {\n    if (this.subscription) {\n      this.subscription.unsubscribe();\n    }\n  }\n  /**\n   * Transform current url to localized one\n   */\n\n\n  transform(query) {\n    if (!query || query.length === 0 || !this.localize.parser.currentLang) {\n      return query;\n    }\n\n    if (equals(query, this.lastKey) && equals(this.lastLanguage, this.localize.parser.currentLang)) {\n      return this.value;\n    }\n\n    this.lastKey = query;\n    this.lastLanguage = this.localize.parser.currentLang;\n    /** translate key and update values */\n\n    this.value = this.localize.translateRoute(query);\n    this.lastKey = query; // if view is already destroyed, ignore firing change detection\n\n    const view = this._ref._view;\n\n    if (view && view.state & VIEW_DESTROYED_STATE) {\n      return this.value;\n    }\n\n    setTimeout(() => {\n      this._ref.detectChanges();\n    }, 0);\n    return this.value;\n  }\n\n}\n\nLocalizeRouterPipe.ɵfac = function LocalizeRouterPipe_Factory(t) {\n  return new (t || LocalizeRouterPipe)(i0.ɵɵdirectiveInject(LocalizeRouterService, 16), i0.ɵɵdirectiveInject(i0.ChangeDetectorRef, 16));\n};\n\nLocalizeRouterPipe.ɵpipe = /* @__PURE__ */i0.ɵɵdefinePipe({\n  name: \"localize\",\n  type: LocalizeRouterPipe,\n  pure: false\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LocalizeRouterPipe, [{\n    type: Pipe,\n    args: [{\n      name: 'localize',\n      pure: false // required to update the value when the promise is resolved\n\n    }]\n  }], function () {\n    return [{\n      type: LocalizeRouterService\n    }, {\n      type: i0.ChangeDetectorRef\n    }];\n  }, null);\n})();\n\nclass GilsdavReuseStrategy {\n  // private handlers: {[key: string]: DetachedRouteHandle} = {};\n  constructor() {}\n\n  shouldDetach(route) {\n    // console.log('shouldDetach', route);\n    return false;\n  }\n\n  store(route, handle) {// console.log('store', route, handle);\n    // console.log('store url', this.getKey(route));\n    // this.handlers[this.getKey(route)] = handle;\n  }\n\n  shouldAttach(route) {\n    // console.log('shouldAttach', route, this.getKey(route));\n    // return !!this.handlers[this.getKey(route)];\n    return false;\n  }\n\n  retrieve(route) {\n    // console.log('retrieve', route);\n    // console.log('retrieve url', this.getKey(route));\n    // const result = this.handlers[this.getKey(route)];\n    // delete this.handlers[this.getKey(route)];\n    // return result;\n    return null;\n  }\n\n  shouldReuseRoute(future, curr) {\n    // console.log('shouldReuseRoute', future, curr, this.getKey(future) === this.getKey(curr));\n    // console.log('shouldReuseRoute', future && curr ? this.getKey(future) === this.getKey(curr) : false);\n    return future && curr ? this.getKey(future) === this.getKey(curr) : false;\n  }\n\n  getKey(route) {\n    // console.log(route.parent.component.toString());\n    if (route.firstChild && route.firstChild.routeConfig && route.firstChild.routeConfig.path && route.firstChild.routeConfig.path.indexOf('**') !== -1) {\n      // WildCard\n      return 'WILDCARD';\n    } else if (!route.data.localizeRouter && (!route.parent || !route.parent.parent) && !route.data.skipRouteLocalization) {\n      // Lang route\n      return 'LANG';\n    } else if (route.routeConfig.matcher) {\n      let keyM = `${this.getKey(route.parent)}/${route.routeConfig.matcher.name}`;\n\n      if (route.data.discriminantPathKey) {\n        keyM = `${keyM}-${route.data.discriminantPathKey}`;\n      }\n\n      return keyM;\n    } else if (route.data.localizeRouter) {\n      let key = `${this.getKey(route.parent)}/${route.data.localizeRouter.path}`;\n\n      if (route.data.discriminantPathKey) {\n        key = `${key}-${route.data.discriminantPathKey}`;\n      }\n\n      return key;\n    } else {\n      let key = route.routeConfig.path;\n\n      if (route.parent) {\n        key = `${this.getKey(route.parent)}/${route.routeConfig.path}`;\n      }\n\n      if (route.data.discriminantPathKey) {\n        key = `${key}-${route.data.discriminantPathKey}`;\n      }\n\n      return key;\n    }\n  }\n\n}\n\nclass LocalizedRouter extends Router {\n  constructor(_rootComponentType, _urlSerializer, _rootContexts, _location, injector, compiler, config, localize) {\n    super(_rootComponentType, _urlSerializer, _rootContexts, _location, injector, compiler, config);\n    this.config = config; // Custom configuration\n\n    const platformId = injector.get(PLATFORM_ID);\n    const isBrowser = isPlatformBrowser(platformId); // __proto__ is needed for preloaded modules be doesn't work with SSR\n    // @ts-ignore\n\n    const configLoader = isBrowser ? this.configLoader.__proto__ : this.configLoader;\n\n    configLoader.loadModuleFactory = loadChildren => {\n      return wrapIntoObservable(loadChildren()).pipe(mergeMap(t => {\n        let compiled;\n\n        if (t instanceof NgModuleFactory) {\n          compiled = of(t);\n        } else {\n          compiled = from(compiler.compileModuleAsync(t));\n        }\n\n        return compiled.pipe(map(factory => {\n          return {\n            moduleType: factory.moduleType,\n            create: parentInjector => {\n              const module = factory.create(parentInjector);\n              const getMethod = module.injector.get.bind(module.injector);\n\n              module.injector['get'] = (token, notFoundValue) => {\n                const getResult = getMethod(token, notFoundValue);\n\n                if (token === ROUTES) {\n                  // translate lazy routes\n                  return localize.initChildRoutes([].concat(...getResult));\n                } else {\n                  return getResult;\n                }\n              };\n\n              return module;\n            }\n          };\n        }));\n      }));\n    }; // (this as any).navigations = (this as any).setupNavigations((this as any).transitions);\n\n  }\n\n}\n\nfunction setupRouter(ref, urlSerializer, contexts, location, injector, compiler, config, localize, opts = {}, urlHandlingStrategy, routeReuseStrategy) {\n  const router = new LocalizedRouter(null, urlSerializer, contexts, location, injector, compiler, flatten(config), localize);\n\n  if (urlHandlingStrategy) {\n    router.urlHandlingStrategy = urlHandlingStrategy;\n  }\n\n  if (routeReuseStrategy) {\n    router.routeReuseStrategy = routeReuseStrategy;\n  }\n\n  if (opts.errorHandler) {\n    router.errorHandler = opts.errorHandler;\n  }\n\n  if (opts.malformedUriErrorHandler) {\n    router.malformedUriErrorHandler = opts.malformedUriErrorHandler;\n  }\n\n  if (opts.enableTracing) {\n    router.events.subscribe(e => {\n      console.group(`Router Event: ${e.constructor.name}`);\n      console.log(e.toString());\n      console.log(e);\n      console.groupEnd();\n    });\n  }\n\n  if (opts.onSameUrlNavigation) {\n    router.onSameUrlNavigation = opts.onSameUrlNavigation;\n  }\n\n  if (opts.paramsInheritanceStrategy) {\n    router.paramsInheritanceStrategy = opts.paramsInheritanceStrategy;\n  }\n\n  if (opts.urlUpdateStrategy) {\n    router.urlUpdateStrategy = opts.urlUpdateStrategy;\n  }\n\n  if (opts.relativeLinkResolution) {\n    router.relativeLinkResolution = opts.relativeLinkResolution;\n  }\n\n  return router;\n}\n\nfunction wrapIntoObservable(value) {\n  if (isObservable(value)) {\n    return value;\n  }\n\n  if (isPromise(value)) {\n    // Use `Promise.resolve()` to wrap promise-like instances.\n    // Required ie when a Resolver returns a AngularJS `$q` promise to correctly trigger the\n    // change detection.\n    return from(Promise.resolve(value));\n  }\n\n  return of(value);\n}\n\nclass ParserInitializer {\n  /**\n   * CTOR\n   */\n  constructor(injector) {\n    this.injector = injector;\n  }\n\n  appInitializer() {\n    const res = this.parser.load(this.routes);\n    return res.then(() => {\n      const localize = this.injector.get(LocalizeRouterService);\n      const router = this.injector.get(Router);\n      const settings = this.injector.get(LocalizeRouterSettings);\n      localize.init();\n\n      if (settings.initialNavigation) {\n        return new Promise(resolve => {\n          // @ts-ignore\n          const oldAfterPreactivation = router.hooks.afterPreactivation;\n          let firstInit = true; // @ts-ignore\n\n          router.hooks.afterPreactivation = () => {\n            if (firstInit) {\n              resolve();\n              firstInit = false;\n\n              localize.hooks._initializedSubject.next(true);\n\n              localize.hooks._initializedSubject.complete();\n            }\n\n            return oldAfterPreactivation();\n          };\n        });\n      } else {\n        localize.hooks._initializedSubject.next(true);\n\n        localize.hooks._initializedSubject.complete();\n      }\n    });\n  }\n\n  generateInitializer(parser, routes) {\n    this.parser = parser;\n    this.routes = routes.reduce((a, b) => a.concat(b));\n    return this.appInitializer;\n  }\n\n}\n\nParserInitializer.ɵfac = function ParserInitializer_Factory(t) {\n  return new (t || ParserInitializer)(i0.ɵɵinject(i0.Injector));\n};\n\nParserInitializer.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n  token: ParserInitializer,\n  factory: ParserInitializer.ɵfac\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(ParserInitializer, [{\n    type: Injectable\n  }], function () {\n    return [{\n      type: i0.Injector\n    }];\n  }, null);\n})();\n\nfunction getAppInitializer(p, parser, routes) {\n  // DeepCopy needed to prevent RAW_ROUTES mutation\n  const routesCopy = deepCopy(routes);\n  return p.generateInitializer(parser, routesCopy).bind(p);\n}\n\nclass LocalizeRouterModule {\n  static forRoot(routes, config = {}) {\n    return {\n      ngModule: LocalizeRouterModule,\n      providers: [{\n        provide: Router,\n        useFactory: setupRouter,\n        deps: [ApplicationRef, UrlSerializer, ChildrenOutletContexts, Location, Injector, Compiler, ROUTES, LocalizeParser, ROUTER_CONFIGURATION, [UrlHandlingStrategy, new Optional()], [RouteReuseStrategy, new Optional()]]\n      }, {\n        provide: LOCALIZE_ROUTER_FORROOT_GUARD,\n        useFactory: provideForRootGuard,\n        deps: [[LocalizeRouterModule, new Optional(), new SkipSelf()]]\n      }, {\n        provide: USE_CACHED_LANG,\n        useValue: config.useCachedLang\n      }, {\n        provide: ALWAYS_SET_PREFIX,\n        useValue: config.alwaysSetPrefix\n      }, {\n        provide: CACHE_NAME,\n        useValue: config.cacheName\n      }, {\n        provide: CACHE_MECHANISM,\n        useValue: config.cacheMechanism\n      }, {\n        provide: DEFAULT_LANG_FUNCTION,\n        useValue: config.defaultLangFunction\n      }, {\n        provide: COOKIE_FORMAT,\n        useValue: config.cookieFormat\n      }, {\n        provide: INITIAL_NAVIGATION,\n        useValue: config.initialNavigation\n      }, LocalizeRouterSettings, config.parser || {\n        provide: LocalizeParser,\n        useClass: DummyLocalizeParser\n      }, {\n        provide: RAW_ROUTES,\n        multi: true,\n        useValue: routes\n      }, LocalizeRouterService, ParserInitializer, {\n        provide: APP_INITIALIZER,\n        multi: true,\n        useFactory: getAppInitializer,\n        deps: [ParserInitializer, LocalizeParser, RAW_ROUTES]\n      }, {\n        provide: RouteReuseStrategy,\n        useClass: GilsdavReuseStrategy\n      }]\n    };\n  }\n\n  static forChild(routes) {\n    return {\n      ngModule: LocalizeRouterModule,\n      providers: [{\n        provide: RAW_ROUTES,\n        multi: true,\n        useValue: routes\n      }]\n    };\n  }\n\n}\n\nLocalizeRouterModule.ɵfac = function LocalizeRouterModule_Factory(t) {\n  return new (t || LocalizeRouterModule)();\n};\n\nLocalizeRouterModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n  type: LocalizeRouterModule\n});\nLocalizeRouterModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n  imports: [[CommonModule, RouterModule, TranslateModule]]\n});\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(LocalizeRouterModule, [{\n    type: NgModule,\n    args: [{\n      imports: [CommonModule, RouterModule, TranslateModule],\n      declarations: [LocalizeRouterPipe],\n      exports: [LocalizeRouterPipe]\n    }]\n  }], null, null);\n})();\n\nfunction provideForRootGuard(localizeRouterModule) {\n  if (localizeRouterModule) {\n    throw new Error(`LocalizeRouterModule.forRoot() called twice. Lazy loaded modules should use LocalizeRouterModule.forChild() instead.`);\n  }\n\n  return 'guarded';\n}\n\nclass LocalizeNgModuleFactory extends NgModuleFactory {\n  constructor(moduleType) {\n    super();\n    this.moduleType = moduleType;\n\n    this.create = parentInjector => {\n      const compiler = parentInjector.get(Compiler);\n      const localize = parentInjector.get(LocalizeParser);\n      const compiled = compiler.compileModuleAndAllComponentsSync(this.moduleType);\n      const moduleRef = compiled.ngModuleFactory.create(parentInjector);\n      const getMethod = moduleRef.injector.get.bind(moduleRef.injector);\n\n      moduleRef.injector['get'] = (token, notFoundValue) => {\n        const getResult = getMethod(token, notFoundValue);\n\n        if (token === ROUTES) {\n          // translate lazy routes\n          return localize.initChildRoutes([].concat(...getResult));\n        } else {\n          return getResult;\n        }\n      };\n\n      return moduleRef;\n    };\n  }\n\n}\n\nfunction translateModule(moduleType) {\n  return new LocalizeNgModuleFactory(moduleType);\n}\n/*\n * Public API Surface of ngx-translate-router\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { ALWAYS_SET_PREFIX, CACHE_MECHANISM, CACHE_NAME, COOKIE_FORMAT, CacheMechanism, DEFAULT_LANG_FUNCTION, DummyLocalizeParser, GilsdavReuseStrategy, INITIAL_NAVIGATION, LOCALIZE_ROUTER_FORROOT_GUARD, LocalizeNgModuleFactory, LocalizeParser, LocalizeRouterModule, LocalizeRouterPipe, LocalizeRouterService, LocalizeRouterSettings, LocalizedRouter, ManualParserLoader, ParserInitializer, RAW_ROUTES, USE_CACHED_LANG, getAppInitializer, provideForRootGuard, setupRouter, translateModule, wrapIntoObservable };","map":{"version":3,"sources":["/Users/steven/Documents/new_story/concept/translate-router-test/node_modules/@gilsdav/ngx-translate-router/fesm2015/gilsdav-ngx-translate-router.mjs"],"names":["i0","InjectionToken","Injectable","Inject","Pipe","PLATFORM_ID","NgModuleFactory","ApplicationRef","Injector","Compiler","Optional","SkipSelf","APP_INITIALIZER","NgModule","i3","NavigationStart","NavigationCancel","Router","ActivatedRoute","ROUTES","UrlSerializer","ChildrenOutletContexts","ROUTER_CONFIGURATION","UrlHandlingStrategy","RouteReuseStrategy","RouterModule","Observable","Subject","ReplaySubject","of","from","isObservable","filter","pairwise","mergeMap","map","i1","TranslateService","TranslateModule","i2","Location","isPlatformBrowser","CommonModule","HttpParams","LOCALIZE_ROUTER_FORROOT_GUARD","RAW_ROUTES","CacheMechanism","USE_CACHED_LANG","CACHE_MECHANISM","CACHE_NAME","COOKIE_FORMAT","INITIAL_NAVIGATION","DEFAULT_LANG_FUNCTION","ALWAYS_SET_PREFIX","LOCALIZE_CACHE_NAME","DEFAULT_COOKIE_FORMAT","DEFAULT_INITIAL_NAVIGATION","LocalizeRouterSettings","constructor","useCachedLang","alwaysSetPrefix","cacheMechanism","LocalStorage","cacheName","defaultLangFunction","cookieFormat","initialNavigation","ɵfac","ɵprov","type","undefined","decorators","args","COOKIE_EXPIRY","LocalizeParser","translate","location","settings","init","routes","selectedLanguage","locales","length","Promise","resolve","locationLang","getLocationLang","browserLang","_getBrowserLang","defaultLang","_cachedLang","setDefaultLang","children","baseRoute","path","redirectTo","pathMatch","wildcardIndex","findIndex","route","_wildcardRoute","splice","i","data","push","_languageRoute","unshift","res","translateRoutes","toPromise","initChildRoutes","_translateRouteTree","language","observer","use","subscribe","translations","_translationObject","currentLang","_translateProperty","next","complete","forEach","skipRouteLocalization","localizeRedirection","indexOf","loadChildren","_loadedConfig","property","prefixLang","routeData","localizeRouter","Object","assign","result","translateRoute","addPrefixToUrl","urlPrefix","url","plitedUrl","split","replace","join","queryParts","Error","pathSegments","part","translateText","queryParamSplit","pathSlices","_returnIfInLocales","getBrowserLang","_cacheWithLocalStorage","SessionStorage","_cacheWithSessionStorage","Cookie","_cacheWithCookies","value","window","localStorage","setItem","getItem","e","sessionStorage","document","cookie","name","encodeURIComponent","cookieTemplate","fullMatch","groupMatch","days","parseInt","date","Date","setTime","getTime","toUTCString","regexp","RegExp","exec","decodeURIComponent","key","escapePrefix","startsWith","fullKey","prefix","getParsedResult","chooseQueryParams","newExtras","currentQueryParams","queryParamsObj","queryParams","formatQueryParams","params","fromObject","toString","getPrefix","getEscapePrefix","ManualParserLoader","load","then","DummyLocalizeParser","equals","o1","o2","t1","t2","keySet","Array","isArray","create","hasOwnProperty","isPromise","obj","deepCopy","object","output","flatten","list","reduce","flat","item","flatItem","concat","LocalizeRouterService","parser","router","routerEvents","initializedSubject","hooks","_initializedSubject","initialized","asObservable","applyConfigToRouter","events","pipe","event","_routeChanged","changeLanguage","lang","extras","useNavigateMethod","rootSnapshot","routerState","snapshot","root","traverseRouteSnapshot","urlSegments","languageSegmentIndex","slice","injectionIndex","lastSlashIndex","lastIndexOf","lastExtras","extrasToApply","navigate","navigateByUrl","firstChild","routeConfig","parseSegmentValue","buildUrlFromSegments","segments","s","matcher","subPathMatchedSegments","parseSegmentValueMatcher","subPathSegments","parent","localizeMatcherParams","localizeMatcher","segment","currentPath","matchedParamName","localizedParamName","val","index","previousEvent","currentEvent","previousLang","latestUrl","cancelCurrentNavigation","currentNavigation","getCurrentNavigation","serializeUrl","extractedUrl","id","transitions","getValue","config","resetConfig","VIEW_DESTROYED_STATE","LocalizeRouterPipe","localize","_ref","subscription","transform","lastKey","ngOnDestroy","unsubscribe","query","lastLanguage","view","_view","state","setTimeout","detectChanges","ChangeDetectorRef","ɵpipe","pure","GilsdavReuseStrategy","shouldDetach","store","handle","shouldAttach","retrieve","shouldReuseRoute","future","curr","getKey","keyM","discriminantPathKey","LocalizedRouter","_rootComponentType","_urlSerializer","_rootContexts","_location","injector","compiler","platformId","get","isBrowser","configLoader","__proto__","loadModuleFactory","wrapIntoObservable","t","compiled","compileModuleAsync","factory","moduleType","parentInjector","module","getMethod","bind","token","notFoundValue","getResult","setupRouter","ref","urlSerializer","contexts","opts","urlHandlingStrategy","routeReuseStrategy","errorHandler","malformedUriErrorHandler","enableTracing","console","group","log","groupEnd","onSameUrlNavigation","paramsInheritanceStrategy","urlUpdateStrategy","relativeLinkResolution","ParserInitializer","appInitializer","oldAfterPreactivation","afterPreactivation","firstInit","generateInitializer","a","b","getAppInitializer","p","routesCopy","LocalizeRouterModule","forRoot","ngModule","providers","provide","useFactory","deps","provideForRootGuard","useValue","useClass","multi","forChild","ɵmod","ɵinj","imports","declarations","exports","localizeRouterModule","LocalizeNgModuleFactory","compileModuleAndAllComponentsSync","moduleRef","ngModuleFactory","translateModule"],"mappings":"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","sourcesContent":["import * as i0 from '@angular/core';\nimport { InjectionToken, Injectable, Inject, Pipe, PLATFORM_ID, NgModuleFactory, ApplicationRef, Injector, Compiler, Optional, SkipSelf, APP_INITIALIZER, NgModule } from '@angular/core';\nimport * as i3 from '@angular/router';\nimport { NavigationStart, NavigationCancel, Router, ActivatedRoute, ROUTES, UrlSerializer, ChildrenOutletContexts, ROUTER_CONFIGURATION, UrlHandlingStrategy, RouteReuseStrategy, RouterModule } from '@angular/router';\nimport { Observable, Subject, ReplaySubject, of, from, isObservable } from 'rxjs';\nimport { filter, pairwise, mergeMap, map } from 'rxjs/operators';\nimport * as i1 from '@ngx-translate/core';\nimport { TranslateService, TranslateModule } from '@ngx-translate/core';\nimport * as i2 from '@angular/common';\nimport { Location, isPlatformBrowser, CommonModule } from '@angular/common';\nimport { HttpParams } from '@angular/common/http';\n\n/**\n * Guard to make sure we have single initialization of forRoot\n */\nconst LOCALIZE_ROUTER_FORROOT_GUARD = new InjectionToken('LOCALIZE_ROUTER_FORROOT_GUARD');\n/**\n * Static provider for keeping track of routes\n */\nconst RAW_ROUTES = new InjectionToken('RAW_ROUTES');\n/**\n * Type for Caching of default language\n */\n// export type CacheMechanism = 'LocalStorage' | 'Cookie';\n/**\n * Namespace for fail proof access of CacheMechanism\n */\nvar CacheMechanism;\n(function (CacheMechanism) {\n    CacheMechanism[\"LocalStorage\"] = \"LocalStorage\";\n    CacheMechanism[\"SessionStorage\"] = \"SessionStorage\";\n    CacheMechanism[\"Cookie\"] = \"Cookie\";\n})(CacheMechanism || (CacheMechanism = {}));\n/**\n * Boolean to indicate whether to use cached language value\n */\nconst USE_CACHED_LANG = new InjectionToken('USE_CACHED_LANG');\n/**\n * Cache mechanism type\n */\nconst CACHE_MECHANISM = new InjectionToken('CACHE_MECHANISM');\n/**\n * Cache name\n */\nconst CACHE_NAME = new InjectionToken('CACHE_NAME');\n/**\n * Cookie cache format\n */\nconst COOKIE_FORMAT = new InjectionToken('COOKIE_FORMAT');\n/**\n * Cookie cache format\n */\nconst INITIAL_NAVIGATION = new InjectionToken('INITIAL_NAVIGATION');\n/**\n * Function for calculating default language\n */\nconst DEFAULT_LANG_FUNCTION = new InjectionToken('DEFAULT_LANG_FUNCTION');\n/**\n * Boolean to indicate whether prefix should be set for single language scenarios\n */\nconst ALWAYS_SET_PREFIX = new InjectionToken('ALWAYS_SET_PREFIX');\nconst LOCALIZE_CACHE_NAME = 'LOCALIZE_DEFAULT_LANGUAGE';\nconst DEFAULT_COOKIE_FORMAT = '{{value}};{{expires}}';\nconst DEFAULT_INITIAL_NAVIGATION = false;\nclass LocalizeRouterSettings {\n    /**\n     * Settings for localize router\n     */\n    constructor(useCachedLang = true, alwaysSetPrefix = true, cacheMechanism = CacheMechanism.LocalStorage, cacheName = LOCALIZE_CACHE_NAME, defaultLangFunction = void 0, cookieFormat = DEFAULT_COOKIE_FORMAT, initialNavigation = DEFAULT_INITIAL_NAVIGATION) {\n        this.useCachedLang = useCachedLang;\n        this.alwaysSetPrefix = alwaysSetPrefix;\n        this.cacheName = cacheName;\n        this.cookieFormat = cookieFormat;\n        this.initialNavigation = initialNavigation;\n        this.cacheMechanism = cacheMechanism;\n        this.defaultLangFunction = defaultLangFunction;\n    }\n}\nLocalizeRouterSettings.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.1.0\", ngImport: i0, type: LocalizeRouterSettings, deps: [{ token: USE_CACHED_LANG }, { token: ALWAYS_SET_PREFIX }, { token: CACHE_MECHANISM }, { token: CACHE_NAME }, { token: DEFAULT_LANG_FUNCTION }, { token: COOKIE_FORMAT }, { token: INITIAL_NAVIGATION }], target: i0.ɵɵFactoryTarget.Injectable });\nLocalizeRouterSettings.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.1.0\", ngImport: i0, type: LocalizeRouterSettings });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.1.0\", ngImport: i0, type: LocalizeRouterSettings, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () {\n        return [{ type: undefined, decorators: [{\n                        type: Inject,\n                        args: [USE_CACHED_LANG]\n                    }] }, { type: undefined, decorators: [{\n                        type: Inject,\n                        args: [ALWAYS_SET_PREFIX]\n                    }] }, { type: undefined, decorators: [{\n                        type: Inject,\n                        args: [CACHE_MECHANISM]\n                    }] }, { type: undefined, decorators: [{\n                        type: Inject,\n                        args: [CACHE_NAME]\n                    }] }, { type: undefined, decorators: [{\n                        type: Inject,\n                        args: [DEFAULT_LANG_FUNCTION]\n                    }] }, { type: undefined, decorators: [{\n                        type: Inject,\n                        args: [COOKIE_FORMAT]\n                    }] }, { type: undefined, decorators: [{\n                        type: Inject,\n                        args: [INITIAL_NAVIGATION]\n                    }] }];\n    } });\n\nconst COOKIE_EXPIRY = 30; // 1 month\n/**\n * Abstract class for parsing localization\n */\nclass LocalizeParser {\n    /**\n     * Loader constructor\n     */\n    constructor(translate, location, settings) {\n        this.translate = translate;\n        this.location = location;\n        this.settings = settings;\n    }\n    /**\n   * Prepare routes to be fully usable by ngx-translate-router\n   * @param routes\n   */\n    /* private initRoutes(routes: Routes, prefix = '') {\n      routes.forEach(route => {\n        if (route.path !== '**') {\n          const routeData: any = route.data = route.data || {};\n          routeData.localizeRouter = {};\n          routeData.localizeRouter.fullPath = `${prefix}/${route.path}`;\n          if (route.children && route.children.length > 0) {\n            this.initRoutes(route.children, routeData.localizeRouter.fullPath);\n          }\n        }\n      });\n    } */\n    /**\n     * Initialize language and routes\n     */\n    init(routes) {\n        let selectedLanguage;\n        // this.initRoutes(routes);\n        this.routes = routes;\n        if (!this.locales || !this.locales.length) {\n            return Promise.resolve();\n        }\n        /** detect current language */\n        const locationLang = this.getLocationLang();\n        const browserLang = this._getBrowserLang();\n        if (this.settings.defaultLangFunction) {\n            this.defaultLang = this.settings.defaultLangFunction(this.locales, this._cachedLang, browserLang);\n        }\n        else {\n            this.defaultLang = this._cachedLang || browserLang || this.locales[0];\n        }\n        selectedLanguage = locationLang || this.defaultLang;\n        this.translate.setDefaultLang(this.defaultLang);\n        let children = [];\n        /** if set prefix is enforced */\n        if (this.settings.alwaysSetPrefix) {\n            const baseRoute = { path: '', redirectTo: this.defaultLang, pathMatch: 'full' };\n            /** extract potential wildcard route */\n            const wildcardIndex = routes.findIndex((route) => route.path === '**');\n            if (wildcardIndex !== -1) {\n                this._wildcardRoute = routes.splice(wildcardIndex, 1)[0];\n            }\n            children = this.routes.splice(0, this.routes.length, baseRoute);\n        }\n        else {\n            children = [...this.routes]; // shallow copy of routes\n        }\n        /** exclude certain routes */\n        for (let i = children.length - 1; i >= 0; i--) {\n            if (children[i].data && children[i].data['skipRouteLocalization']) {\n                if (this.settings.alwaysSetPrefix) {\n                    // add directly to routes\n                    this.routes.push(children[i]);\n                }\n                // remove from routes to translate only if doesn't have to translate `redirectTo` property\n                if (children[i].redirectTo === undefined || !(children[i].data['skipRouteLocalization']['localizeRedirectTo'])) {\n                    children.splice(i, 1);\n                }\n            }\n        }\n        /** append children routes */\n        if (children && children.length) {\n            if (this.locales.length > 1 || this.settings.alwaysSetPrefix) {\n                this._languageRoute = { children: children };\n                this.routes.unshift(this._languageRoute);\n            }\n        }\n        /** ...and potential wildcard route */\n        if (this._wildcardRoute && this.settings.alwaysSetPrefix) {\n            this.routes.push(this._wildcardRoute);\n        }\n        /** translate routes */\n        const res = this.translateRoutes(selectedLanguage);\n        return res.toPromise();\n    }\n    initChildRoutes(routes) {\n        this._translateRouteTree(routes);\n        return routes;\n    }\n    /**\n     * Translate routes to selected language\n     */\n    translateRoutes(language) {\n        return new Observable((observer) => {\n            this._cachedLang = language;\n            if (this._languageRoute) {\n                this._languageRoute.path = language;\n            }\n            this.translate.use(language).subscribe((translations) => {\n                this._translationObject = translations;\n                this.currentLang = language;\n                if (this._languageRoute) {\n                    if (this._languageRoute) {\n                        this._translateRouteTree(this._languageRoute.children);\n                    }\n                    // if there is wildcard route\n                    if (this._wildcardRoute && this._wildcardRoute.redirectTo) {\n                        this._translateProperty(this._wildcardRoute, 'redirectTo', true);\n                    }\n                }\n                else {\n                    this._translateRouteTree(this.routes);\n                }\n                observer.next(void 0);\n                observer.complete();\n            });\n        });\n    }\n    /**\n     * Translate the route node and recursively call for all it's children\n     */\n    _translateRouteTree(routes) {\n        routes.forEach((route) => {\n            const skipRouteLocalization = (route.data && route.data['skipRouteLocalization']);\n            const localizeRedirection = !skipRouteLocalization || skipRouteLocalization['localizeRedirectTo'];\n            if (route.redirectTo && localizeRedirection) {\n                this._translateProperty(route, 'redirectTo', !route.redirectTo.indexOf('/'));\n            }\n            if (!skipRouteLocalization) {\n                if (route.path !== null && route.path !== undefined /* && route.path !== '**'*/) {\n                    this._translateProperty(route, 'path');\n                }\n                if (route.children) {\n                    this._translateRouteTree(route.children);\n                }\n                if (route.loadChildren && route._loadedConfig) {\n                    this._translateRouteTree(route._loadedConfig.routes);\n                }\n            }\n        });\n    }\n    /**\n     * Translate property\n     * If first time translation then add original to route data object\n     */\n    _translateProperty(route, property, prefixLang) {\n        // set property to data if not there yet\n        const routeData = route.data = route.data || {};\n        if (!routeData.localizeRouter) {\n            routeData.localizeRouter = {};\n        }\n        if (!routeData.localizeRouter[property]) {\n            routeData.localizeRouter = Object.assign(Object.assign({}, routeData.localizeRouter), { [property]: route[property] });\n        }\n        const result = this.translateRoute(routeData.localizeRouter[property]);\n        route[property] = prefixLang ? this.addPrefixToUrl(result) : result;\n    }\n    get urlPrefix() {\n        if (this.settings.alwaysSetPrefix || this.currentLang !== this.defaultLang) {\n            return this.currentLang ? this.currentLang : this.defaultLang;\n        }\n        else {\n            return '';\n        }\n    }\n    /**\n     * Add current lang as prefix to given url.\n     */\n    addPrefixToUrl(url) {\n        const plitedUrl = url.split('?');\n        plitedUrl[0] = plitedUrl[0].replace(/\\/$/, '');\n        return `/${this.urlPrefix}${plitedUrl.join('?')}`;\n    }\n    /**\n     * Translate route and return observable\n     */\n    translateRoute(path) {\n        const queryParts = path.split('?');\n        if (queryParts.length > 2) {\n            throw Error('There should be only one query parameter block in the URL');\n        }\n        const pathSegments = queryParts[0].split('/');\n        /** collect observables  */\n        return pathSegments\n            .map((part) => part.length ? this.translateText(part) : part)\n            .join('/') +\n            (queryParts.length > 1 ? `?${queryParts[1]}` : '');\n    }\n    /**\n     * Get language from url\n     */\n    getLocationLang(url) {\n        const queryParamSplit = (url || this.location.path()).split(/[\\?;]/);\n        let pathSlices = [];\n        if (queryParamSplit.length > 0) {\n            pathSlices = queryParamSplit[0].split('/');\n        }\n        if (pathSlices.length > 1 && this.locales.indexOf(pathSlices[1]) !== -1) {\n            return pathSlices[1];\n        }\n        if (pathSlices.length && this.locales.indexOf(pathSlices[0]) !== -1) {\n            return pathSlices[0];\n        }\n        return null;\n    }\n    /**\n     * Get user's language set in the browser\n     */\n    _getBrowserLang() {\n        return this._returnIfInLocales(this.translate.getBrowserLang());\n    }\n    /**\n     * Get language from local storage or cookie\n     */\n    get _cachedLang() {\n        if (!this.settings.useCachedLang) {\n            return;\n        }\n        if (this.settings.cacheMechanism === CacheMechanism.LocalStorage) {\n            return this._cacheWithLocalStorage();\n        }\n        if (this.settings.cacheMechanism === CacheMechanism.SessionStorage) {\n            return this._cacheWithSessionStorage();\n        }\n        if (this.settings.cacheMechanism === CacheMechanism.Cookie) {\n            return this._cacheWithCookies();\n        }\n    }\n    /**\n     * Save language to local storage or cookie\n     */\n    set _cachedLang(value) {\n        if (!this.settings.useCachedLang) {\n            return;\n        }\n        if (this.settings.cacheMechanism === CacheMechanism.LocalStorage) {\n            this._cacheWithLocalStorage(value);\n        }\n        if (this.settings.cacheMechanism === CacheMechanism.SessionStorage) {\n            this._cacheWithSessionStorage(value);\n        }\n        if (this.settings.cacheMechanism === CacheMechanism.Cookie) {\n            this._cacheWithCookies(value);\n        }\n    }\n    /**\n     * Cache value to local storage\n     */\n    _cacheWithLocalStorage(value) {\n        try {\n            if (typeof window === 'undefined' || typeof window.localStorage === 'undefined') {\n                return;\n            }\n            if (value) {\n                window.localStorage.setItem(this.settings.cacheName, value);\n                return;\n            }\n            return this._returnIfInLocales(window.localStorage.getItem(this.settings.cacheName));\n        }\n        catch (e) {\n            // weird Safari issue in private mode, where LocalStorage is defined but throws error on access\n            return;\n        }\n    }\n    /**\n     * Cache value to session storage\n     */\n    _cacheWithSessionStorage(value) {\n        try {\n            if (typeof window === 'undefined' || typeof window.sessionStorage === 'undefined') {\n                return;\n            }\n            if (value) {\n                window.sessionStorage.setItem(this.settings.cacheName, value);\n                return;\n            }\n            return this._returnIfInLocales(window.sessionStorage.getItem(this.settings.cacheName));\n        }\n        catch (e) {\n            return;\n        }\n    }\n    /**\n     * Cache value via cookies\n     */\n    _cacheWithCookies(value) {\n        try {\n            if (typeof document === 'undefined' || typeof document.cookie === 'undefined') {\n                return;\n            }\n            const name = encodeURIComponent(this.settings.cacheName);\n            if (value) {\n                let cookieTemplate = `${this.settings.cookieFormat}`;\n                cookieTemplate = cookieTemplate\n                    .replace('{{value}}', `${name}=${encodeURIComponent(value)}`)\n                    .replace(/{{expires:?(\\d+)?}}/g, (fullMatch, groupMatch) => {\n                    const days = groupMatch === undefined ? COOKIE_EXPIRY : parseInt(groupMatch, 10);\n                    const date = new Date();\n                    date.setTime(date.getTime() + days * 86400000);\n                    return `expires=${date.toUTCString()}`;\n                });\n                document.cookie = cookieTemplate;\n                return;\n            }\n            const regexp = new RegExp('(?:^' + name + '|;\\\\s*' + name + ')=(.*?)(?:;|$)', 'g');\n            const result = regexp.exec(document.cookie);\n            return decodeURIComponent(result[1]);\n        }\n        catch (e) {\n            return; // should not happen but better safe than sorry (can happen by using domino)\n        }\n    }\n    /**\n     * Check if value exists in locales list\n     */\n    _returnIfInLocales(value) {\n        if (value && this.locales.indexOf(value) !== -1) {\n            return value;\n        }\n        return null;\n    }\n    /**\n     * Get translated value\n     */\n    translateText(key) {\n        if (this.escapePrefix && key.startsWith(this.escapePrefix)) {\n            return key.replace(this.escapePrefix, '');\n        }\n        else {\n            if (!this._translationObject) {\n                return key;\n            }\n            const fullKey = this.prefix + key;\n            const res = this.translate.getParsedResult(this._translationObject, fullKey);\n            return res !== fullKey ? res : key;\n        }\n    }\n    /**\n     * Strategy to choose between new or old queryParams\n     * @param newExtras extras that containes new QueryParams\n     * @param currentQueryParams current query params\n     */\n    chooseQueryParams(newExtras, currentQueryParams) {\n        let queryParamsObj;\n        if (newExtras && newExtras.queryParams) {\n            queryParamsObj = newExtras.queryParams;\n        }\n        else if (currentQueryParams) {\n            queryParamsObj = currentQueryParams;\n        }\n        return queryParamsObj;\n    }\n    /**\n     * Format query params from object to string.\n     * Exemple of result: `param=value&param2=value2`\n     * @param params query params object\n     */\n    formatQueryParams(params) {\n        return new HttpParams({ fromObject: params }).toString();\n    }\n    /**\n     * Get translation key prefix from config\n     */\n    getPrefix() {\n        return this.prefix;\n    }\n    /**\n     * Get escape translation prefix from config\n     */\n    getEscapePrefix() {\n        return this.escapePrefix;\n    }\n}\nLocalizeParser.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.1.0\", ngImport: i0, type: LocalizeParser, deps: [{ token: TranslateService }, { token: Location }, { token: LocalizeRouterSettings }], target: i0.ɵɵFactoryTarget.Injectable });\nLocalizeParser.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.1.0\", ngImport: i0, type: LocalizeParser });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.1.0\", ngImport: i0, type: LocalizeParser, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () {\n        return [{ type: i1.TranslateService, decorators: [{\n                        type: Inject,\n                        args: [TranslateService]\n                    }] }, { type: i2.Location, decorators: [{\n                        type: Inject,\n                        args: [Location]\n                    }] }, { type: LocalizeRouterSettings, decorators: [{\n                        type: Inject,\n                        args: [LocalizeRouterSettings]\n                    }] }];\n    } });\n/**\n * Manually set configuration\n */\nclass ManualParserLoader extends LocalizeParser {\n    /**\n     * CTOR\n     */\n    constructor(translate, location, settings, locales = ['en'], prefix = 'ROUTES.', escapePrefix = '') {\n        super(translate, location, settings);\n        this.locales = locales;\n        this.prefix = prefix || '';\n        this.escapePrefix = escapePrefix || '';\n    }\n    /**\n     * Initialize or append routes\n     */\n    load(routes) {\n        return new Promise((resolve) => {\n            this.init(routes).then(resolve);\n        });\n    }\n}\nclass DummyLocalizeParser extends LocalizeParser {\n    load(routes) {\n        return new Promise((resolve) => {\n            this.init(routes).then(resolve);\n        });\n    }\n}\nDummyLocalizeParser.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.1.0\", ngImport: i0, type: DummyLocalizeParser, deps: null, target: i0.ɵɵFactoryTarget.Injectable });\nDummyLocalizeParser.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.1.0\", ngImport: i0, type: DummyLocalizeParser });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.1.0\", ngImport: i0, type: DummyLocalizeParser, decorators: [{\n            type: Injectable\n        }] });\n\n/**\n * Compare if two objects are same\n */\nfunction equals(o1, o2) {\n    if (o1 === o2) {\n        return true;\n    }\n    if (o1 === null || o2 === null) {\n        return false;\n    }\n    if (o1 !== o1 && o2 !== o2) {\n        return true; // NaN === NaN\n    }\n    const t1 = typeof o1, t2 = typeof o2;\n    let length, key, keySet;\n    if (t1 === t2 && t1 === 'object') {\n        if (Array.isArray(o1)) {\n            if (!Array.isArray(o2)) {\n                return false;\n            }\n            if ((length = o1.length) === o2.length) {\n                for (key = 0; key < length; key++) {\n                    if (!equals(o1[key], o2[key])) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n        }\n        else {\n            if (Array.isArray(o2)) {\n                return false;\n            }\n            keySet = Object.create(null);\n            for (key in o1) {\n                if (o1.hasOwnProperty(key)) {\n                    if (!equals(o1[key], o2[key])) {\n                        return false;\n                    }\n                    keySet[key] = true;\n                }\n            }\n            for (key in o2) {\n                if (o2.hasOwnProperty(key)) {\n                    if (!(key in keySet) && typeof o2[key] !== 'undefined') {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Determine if the argument is shaped like a Promise\n */\nfunction isPromise(obj) {\n    // allow any Promise/A+ compliant thenable.\n    // It's up to the caller to ensure that obj.then conforms to the spec\n    return !!obj && typeof obj.then === 'function';\n}\n/**\n * Deep copy of object and array\n */\nfunction deepCopy(object) {\n    const output = Array.isArray(object) ? [] : {};\n    for (const data in object) {\n        if (data) {\n            const value = object[data];\n            output[data] = (typeof value === 'object') ? deepCopy(value) : value;\n        }\n    }\n    return output;\n}\nfunction flatten(list) {\n    return list.reduce((flat, item) => {\n        const flatItem = Array.isArray(item) ? flatten(item) : item;\n        return flat.concat(flatItem);\n    }, []);\n}\n\n/**\n * Localization service\n * modifyRoutes\n */\nclass LocalizeRouterService {\n    /**\n     * CTOR\n     */\n    constructor(parser, settings, router, route /*,\n    @Inject(Location) private location: Location*/) {\n        this.parser = parser;\n        this.settings = settings;\n        this.router = router;\n        this.route = route;\n        this.routerEvents = new Subject();\n        const initializedSubject = new ReplaySubject(1);\n        this.hooks = {\n            _initializedSubject: initializedSubject,\n            initialized: initializedSubject.asObservable()\n        };\n    }\n    /**\n     * Start up the service\n     */\n    init() {\n        this.applyConfigToRouter(this.parser.routes);\n        // subscribe to router events\n        this.router.events\n            .pipe(filter(event => event instanceof NavigationStart), pairwise())\n            .subscribe(this._routeChanged());\n        if (this.settings.initialNavigation) {\n            this.router.initialNavigation();\n        }\n    }\n    /**\n     * Change language and navigate to translated route\n     */\n    changeLanguage(lang, extras, useNavigateMethod) {\n        if (lang !== this.parser.currentLang) {\n            const rootSnapshot = this.router.routerState.snapshot.root;\n            this.parser.translateRoutes(lang).subscribe(() => {\n                let url = this.traverseRouteSnapshot(rootSnapshot);\n                url = this.translateRoute(url);\n                if (!this.settings.alwaysSetPrefix) {\n                    let urlSegments = url.split('/');\n                    const languageSegmentIndex = urlSegments.indexOf(this.parser.currentLang);\n                    // If the default language has no prefix make sure to remove and add it when necessary\n                    if (this.parser.currentLang === this.parser.defaultLang) {\n                        // Remove the language prefix from url when current language is the default language\n                        if (languageSegmentIndex === 0 || (languageSegmentIndex === 1 && urlSegments[0] === '')) {\n                            // Remove the current aka default language prefix from the url\n                            urlSegments = urlSegments.slice(0, languageSegmentIndex).concat(urlSegments.slice(languageSegmentIndex + 1));\n                        }\n                    }\n                    else {\n                        // When coming from a default language it's possible that the url doesn't contain the language, make sure it does.\n                        if (languageSegmentIndex === -1) {\n                            // If the url starts with a slash make sure to keep it.\n                            const injectionIndex = urlSegments[0] === '' ? 1 : 0;\n                            urlSegments = urlSegments.slice(0, injectionIndex).concat(this.parser.currentLang, urlSegments.slice(injectionIndex));\n                        }\n                    }\n                    url = urlSegments.join('/');\n                }\n                // Prevent multiple \"/\" character\n                url = url.replace(/\\/+/g, '/');\n                const lastSlashIndex = url.lastIndexOf('/');\n                if (lastSlashIndex > 0 && lastSlashIndex === url.length - 1) {\n                    url = url.slice(0, -1);\n                }\n                const queryParamsObj = this.parser.chooseQueryParams(extras, this.route.snapshot.queryParams);\n                this.applyConfigToRouter(this.parser.routes);\n                this.lastExtras = extras;\n                if (useNavigateMethod) {\n                    const extrasToApply = extras ? Object.assign({}, extras) : {};\n                    if (queryParamsObj) {\n                        extrasToApply.queryParams = queryParamsObj;\n                    }\n                    this.router.navigate([url], extrasToApply);\n                }\n                else {\n                    let queryParams = this.parser.formatQueryParams(queryParamsObj);\n                    queryParams = queryParams ? `?${queryParams}` : '';\n                    this.router.navigateByUrl(`${url}${queryParams}`, extras);\n                }\n            });\n        }\n    }\n    /**\n     * Traverses through the tree to assemble new translated url\n     */\n    traverseRouteSnapshot(snapshot) {\n        if (snapshot.firstChild && snapshot.routeConfig) {\n            return `${this.parseSegmentValue(snapshot)}/${this.traverseRouteSnapshot(snapshot.firstChild)}`;\n        }\n        else if (snapshot.firstChild) {\n            return this.traverseRouteSnapshot(snapshot.firstChild);\n        }\n        else {\n            return this.parseSegmentValue(snapshot);\n        }\n        /* if (snapshot.firstChild && snapshot.firstChild.routeConfig && snapshot.firstChild.routeConfig.path) {\n          if (snapshot.firstChild.routeConfig.path !== '**') {\n            return this.parseSegmentValue(snapshot) + '/' + this.traverseRouteSnapshot(snapshot.firstChild);\n          } else {\n            return this.parseSegmentValue(snapshot.firstChild);\n          }\n        }\n        return this.parseSegmentValue(snapshot); */\n    }\n    /**\n     * Build URL from segments and snapshot (for params)\n     */\n    buildUrlFromSegments(snapshot, segments) {\n        return segments.map((s, i) => s.indexOf(':') === 0 ? snapshot.url[i].path : s).join('/');\n    }\n    /**\n     * Extracts new segment value based on routeConfig and url\n     */\n    parseSegmentValue(snapshot) {\n        if (snapshot.routeConfig && snapshot.routeConfig.matcher) {\n            const subPathMatchedSegments = this.parseSegmentValueMatcher(snapshot);\n            return this.buildUrlFromSegments(snapshot, subPathMatchedSegments);\n        }\n        else if (snapshot.data.localizeRouter) {\n            const path = snapshot.data.localizeRouter.path;\n            const subPathSegments = path.split('/');\n            return this.buildUrlFromSegments(snapshot, subPathSegments);\n        }\n        else if (snapshot.parent && snapshot.parent.parent) { // Not lang route and no localizeRouter data = excluded path\n            const path = snapshot.routeConfig.path;\n            const subPathSegments = path.split('/');\n            return this.buildUrlFromSegments(snapshot, subPathSegments);\n        }\n        else {\n            return '';\n        }\n        /* if (snapshot.routeConfig) {\n          if (snapshot.routeConfig.path === '**') {\n            return snapshot.url.filter((segment: UrlSegment) => segment.path).map((segment: UrlSegment) => segment.path).join('/');\n          } else {\n            const subPathSegments = snapshot.routeConfig.path.split('/');\n            return subPathSegments.map((s: string, i: number) => s.indexOf(':') === 0 ? snapshot.url[i].path : s).join('/');\n          }\n        }\n        return ''; */\n    }\n    parseSegmentValueMatcher(snapshot) {\n        const localizeMatcherParams = snapshot.data && snapshot.data.localizeMatcher && snapshot.data.localizeMatcher.params || {};\n        const subPathSegments = snapshot.url\n            .map((segment) => {\n            const currentPath = segment.path;\n            const matchedParamName = segment.localizedParamName;\n            const val = (matchedParamName && localizeMatcherParams[matchedParamName]) ?\n                localizeMatcherParams[matchedParamName](currentPath) : null;\n            return val || `${this.parser.getEscapePrefix()}${currentPath}`;\n        });\n        return subPathSegments;\n    }\n    /**\n     * Translate route to current language\n     * If new language is explicitly provided then replace language part in url with new language\n     */\n    translateRoute(path) {\n        if (typeof path === 'string') {\n            const url = this.parser.translateRoute(path);\n            return !path.indexOf('/') ? this.parser.addPrefixToUrl(url) : url;\n        }\n        // it's an array\n        const result = [];\n        path.forEach((segment, index) => {\n            if (typeof segment === 'string') {\n                const res = this.parser.translateRoute(segment);\n                if (!index && !segment.indexOf('/')) {\n                    result.push(this.parser.addPrefixToUrl(res));\n                }\n                else {\n                    result.push(res);\n                }\n            }\n            else {\n                result.push(segment);\n            }\n        });\n        return result;\n    }\n    /**\n     * Event handler to react on route change\n     */\n    _routeChanged() {\n        return ([previousEvent, currentEvent]) => {\n            const previousLang = this.parser.getLocationLang(previousEvent.url) || this.parser.defaultLang;\n            const currentLang = this.parser.getLocationLang(currentEvent.url) || this.parser.defaultLang;\n            const lastExtras = this.lastExtras;\n            if (currentLang !== previousLang && this.latestUrl !== currentEvent.url) {\n                this.latestUrl = currentEvent.url;\n                this.cancelCurrentNavigation();\n                this.parser.translateRoutes(currentLang)\n                    .subscribe(() => {\n                    // Reset routes again once they are all translated\n                    this.applyConfigToRouter(this.parser.routes);\n                    // Clear global extras\n                    this.lastExtras = undefined;\n                    // Init new navigation with same url to take new congif in consideration\n                    this.router.navigateByUrl(currentEvent.url, lastExtras);\n                    // Fire route change event\n                    this.routerEvents.next(currentLang);\n                });\n            }\n            this.latestUrl = currentEvent.url;\n        };\n    }\n    /**\n     * Drop the current Navigation\n     */\n    cancelCurrentNavigation() {\n        const currentNavigation = this.router.getCurrentNavigation();\n        const url = this.router.serializeUrl(currentNavigation.extractedUrl);\n        this.router.events.next(new NavigationCancel(currentNavigation.id, url, ''));\n        this.router.transitions.next(Object.assign(Object.assign({}, this.router.transitions.getValue()), { id: 0 }));\n    }\n    /**\n     * Apply config to Angular RouterModule\n     * @param config routes to apply\n     */\n    applyConfigToRouter(config) {\n        this.router.resetConfig(deepCopy(config));\n    }\n}\nLocalizeRouterService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.1.0\", ngImport: i0, type: LocalizeRouterService, deps: [{ token: LocalizeParser }, { token: LocalizeRouterSettings }, { token: Router }, { token: ActivatedRoute }], target: i0.ɵɵFactoryTarget.Injectable });\nLocalizeRouterService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.1.0\", ngImport: i0, type: LocalizeRouterService });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.1.0\", ngImport: i0, type: LocalizeRouterService, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () {\n        return [{ type: LocalizeParser, decorators: [{\n                        type: Inject,\n                        args: [LocalizeParser]\n                    }] }, { type: LocalizeRouterSettings, decorators: [{\n                        type: Inject,\n                        args: [LocalizeRouterSettings]\n                    }] }, { type: i3.Router, decorators: [{\n                        type: Inject,\n                        args: [Router]\n                    }] }, { type: i3.ActivatedRoute, decorators: [{\n                        type: Inject,\n                        args: [ActivatedRoute]\n                    }] }];\n    } });\n\nconst VIEW_DESTROYED_STATE = 128;\nclass LocalizeRouterPipe {\n    /**\n     * CTOR\n     */\n    constructor(localize, _ref) {\n        this.localize = localize;\n        this._ref = _ref;\n        this.value = '';\n        this.subscription = this.localize.routerEvents.subscribe(() => {\n            this.transform(this.lastKey);\n        });\n    }\n    ngOnDestroy() {\n        if (this.subscription) {\n            this.subscription.unsubscribe();\n        }\n    }\n    /**\n     * Transform current url to localized one\n     */\n    transform(query) {\n        if (!query || query.length === 0 || !this.localize.parser.currentLang) {\n            return query;\n        }\n        if (equals(query, this.lastKey) && equals(this.lastLanguage, this.localize.parser.currentLang)) {\n            return this.value;\n        }\n        this.lastKey = query;\n        this.lastLanguage = this.localize.parser.currentLang;\n        /** translate key and update values */\n        this.value = this.localize.translateRoute(query);\n        this.lastKey = query;\n        // if view is already destroyed, ignore firing change detection\n        const view = this._ref._view;\n        if (view && (view.state & VIEW_DESTROYED_STATE)) {\n            return this.value;\n        }\n        setTimeout(() => {\n            this._ref.detectChanges();\n        }, 0);\n        return this.value;\n    }\n}\nLocalizeRouterPipe.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.1.0\", ngImport: i0, type: LocalizeRouterPipe, deps: [{ token: LocalizeRouterService }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Pipe });\nLocalizeRouterPipe.ɵpipe = i0.ɵɵngDeclarePipe({ minVersion: \"12.0.0\", version: \"13.1.0\", ngImport: i0, type: LocalizeRouterPipe, name: \"localize\", pure: false });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.1.0\", ngImport: i0, type: LocalizeRouterPipe, decorators: [{\n            type: Pipe,\n            args: [{\n                    name: 'localize',\n                    pure: false // required to update the value when the promise is resolved\n                }]\n        }], ctorParameters: function () { return [{ type: LocalizeRouterService }, { type: i0.ChangeDetectorRef }]; } });\n\nclass GilsdavReuseStrategy {\n    // private handlers: {[key: string]: DetachedRouteHandle} = {};\n    constructor() {\n    }\n    shouldDetach(route) {\n        // console.log('shouldDetach', route);\n        return false;\n    }\n    store(route, handle) {\n        // console.log('store', route, handle);\n        // console.log('store url', this.getKey(route));\n        // this.handlers[this.getKey(route)] = handle;\n    }\n    shouldAttach(route) {\n        // console.log('shouldAttach', route, this.getKey(route));\n        // return !!this.handlers[this.getKey(route)];\n        return false;\n    }\n    retrieve(route) {\n        // console.log('retrieve', route);\n        // console.log('retrieve url', this.getKey(route));\n        // const result = this.handlers[this.getKey(route)];\n        // delete this.handlers[this.getKey(route)];\n        // return result;\n        return null;\n    }\n    shouldReuseRoute(future, curr) {\n        // console.log('shouldReuseRoute', future, curr, this.getKey(future) === this.getKey(curr));\n        // console.log('shouldReuseRoute', future && curr ? this.getKey(future) === this.getKey(curr) : false);\n        return future && curr ? this.getKey(future) === this.getKey(curr) : false;\n    }\n    getKey(route) {\n        // console.log(route.parent.component.toString());\n        if (route.firstChild && route.firstChild.routeConfig && route.firstChild.routeConfig.path &&\n            route.firstChild.routeConfig.path.indexOf('**') !== -1) { // WildCard\n            return 'WILDCARD';\n        }\n        else if (!route.data.localizeRouter && (!route.parent || !route.parent.parent) && !route.data.skipRouteLocalization) { // Lang route\n            return 'LANG';\n        }\n        else if (route.routeConfig.matcher) {\n            let keyM = `${this.getKey(route.parent)}/${route.routeConfig.matcher.name}`;\n            if (route.data.discriminantPathKey) {\n                keyM = `${keyM}-${route.data.discriminantPathKey}`;\n            }\n            return keyM;\n        }\n        else if (route.data.localizeRouter) {\n            let key = `${this.getKey(route.parent)}/${route.data.localizeRouter.path}`;\n            if (route.data.discriminantPathKey) {\n                key = `${key}-${route.data.discriminantPathKey}`;\n            }\n            return key;\n        }\n        else {\n            let key = route.routeConfig.path;\n            if (route.parent) {\n                key = `${this.getKey(route.parent)}/${route.routeConfig.path}`;\n            }\n            if (route.data.discriminantPathKey) {\n                key = `${key}-${route.data.discriminantPathKey}`;\n            }\n            return key;\n        }\n    }\n}\n\nclass LocalizedRouter extends Router {\n    constructor(_rootComponentType, _urlSerializer, _rootContexts, _location, injector, compiler, config, localize) {\n        super(_rootComponentType, _urlSerializer, _rootContexts, _location, injector, compiler, config);\n        this.config = config;\n        // Custom configuration\n        const platformId = injector.get(PLATFORM_ID);\n        const isBrowser = isPlatformBrowser(platformId);\n        // __proto__ is needed for preloaded modules be doesn't work with SSR\n        // @ts-ignore\n        const configLoader = isBrowser ? this.configLoader.__proto__ : this.configLoader;\n        configLoader.loadModuleFactory = (loadChildren) => {\n            return wrapIntoObservable(loadChildren()).pipe(mergeMap((t) => {\n                let compiled;\n                if (t instanceof NgModuleFactory) {\n                    compiled = of(t);\n                }\n                else {\n                    compiled = from(compiler.compileModuleAsync(t));\n                }\n                return compiled.pipe(map(factory => {\n                    return {\n                        moduleType: factory.moduleType,\n                        create: (parentInjector) => {\n                            const module = factory.create(parentInjector);\n                            const getMethod = module.injector.get.bind(module.injector);\n                            module.injector['get'] = (token, notFoundValue) => {\n                                const getResult = getMethod(token, notFoundValue);\n                                if (token === ROUTES) {\n                                    // translate lazy routes\n                                    return localize.initChildRoutes([].concat(...getResult));\n                                }\n                                else {\n                                    return getResult;\n                                }\n                            };\n                            return module;\n                        }\n                    };\n                }));\n            }));\n        };\n        // (this as any).navigations = (this as any).setupNavigations((this as any).transitions);\n    }\n}\nfunction setupRouter(ref, urlSerializer, contexts, location, injector, compiler, config, localize, opts = {}, urlHandlingStrategy, routeReuseStrategy) {\n    const router = new LocalizedRouter(null, urlSerializer, contexts, location, injector, compiler, flatten(config), localize);\n    if (urlHandlingStrategy) {\n        router.urlHandlingStrategy = urlHandlingStrategy;\n    }\n    if (routeReuseStrategy) {\n        router.routeReuseStrategy = routeReuseStrategy;\n    }\n    if (opts.errorHandler) {\n        router.errorHandler = opts.errorHandler;\n    }\n    if (opts.malformedUriErrorHandler) {\n        router.malformedUriErrorHandler = opts.malformedUriErrorHandler;\n    }\n    if (opts.enableTracing) {\n        router.events.subscribe((e) => {\n            console.group(`Router Event: ${e.constructor.name}`);\n            console.log(e.toString());\n            console.log(e);\n            console.groupEnd();\n        });\n    }\n    if (opts.onSameUrlNavigation) {\n        router.onSameUrlNavigation = opts.onSameUrlNavigation;\n    }\n    if (opts.paramsInheritanceStrategy) {\n        router.paramsInheritanceStrategy = opts.paramsInheritanceStrategy;\n    }\n    if (opts.urlUpdateStrategy) {\n        router.urlUpdateStrategy = opts.urlUpdateStrategy;\n    }\n    if (opts.relativeLinkResolution) {\n        router.relativeLinkResolution = opts.relativeLinkResolution;\n    }\n    return router;\n}\nfunction wrapIntoObservable(value) {\n    if (isObservable(value)) {\n        return value;\n    }\n    if (isPromise(value)) {\n        // Use `Promise.resolve()` to wrap promise-like instances.\n        // Required ie when a Resolver returns a AngularJS `$q` promise to correctly trigger the\n        // change detection.\n        return from(Promise.resolve(value));\n    }\n    return of(value);\n}\n\nclass ParserInitializer {\n    /**\n     * CTOR\n     */\n    constructor(injector) {\n        this.injector = injector;\n    }\n    appInitializer() {\n        const res = this.parser.load(this.routes);\n        return res.then(() => {\n            const localize = this.injector.get(LocalizeRouterService);\n            const router = this.injector.get(Router);\n            const settings = this.injector.get(LocalizeRouterSettings);\n            localize.init();\n            if (settings.initialNavigation) {\n                return new Promise(resolve => {\n                    // @ts-ignore\n                    const oldAfterPreactivation = router.hooks.afterPreactivation;\n                    let firstInit = true;\n                    // @ts-ignore\n                    router.hooks.afterPreactivation = () => {\n                        if (firstInit) {\n                            resolve();\n                            firstInit = false;\n                            localize.hooks._initializedSubject.next(true);\n                            localize.hooks._initializedSubject.complete();\n                        }\n                        return oldAfterPreactivation();\n                    };\n                });\n            }\n            else {\n                localize.hooks._initializedSubject.next(true);\n                localize.hooks._initializedSubject.complete();\n            }\n        });\n    }\n    generateInitializer(parser, routes) {\n        this.parser = parser;\n        this.routes = routes.reduce((a, b) => a.concat(b));\n        return this.appInitializer;\n    }\n}\nParserInitializer.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.1.0\", ngImport: i0, type: ParserInitializer, deps: [{ token: i0.Injector }], target: i0.ɵɵFactoryTarget.Injectable });\nParserInitializer.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: \"12.0.0\", version: \"13.1.0\", ngImport: i0, type: ParserInitializer });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.1.0\", ngImport: i0, type: ParserInitializer, decorators: [{\n            type: Injectable\n        }], ctorParameters: function () { return [{ type: i0.Injector }]; } });\nfunction getAppInitializer(p, parser, routes) {\n    // DeepCopy needed to prevent RAW_ROUTES mutation\n    const routesCopy = deepCopy(routes);\n    return p.generateInitializer(parser, routesCopy).bind(p);\n}\nclass LocalizeRouterModule {\n    static forRoot(routes, config = {}) {\n        return {\n            ngModule: LocalizeRouterModule,\n            providers: [\n                {\n                    provide: Router,\n                    useFactory: setupRouter,\n                    deps: [\n                        ApplicationRef,\n                        UrlSerializer,\n                        ChildrenOutletContexts,\n                        Location,\n                        Injector,\n                        Compiler,\n                        ROUTES,\n                        LocalizeParser,\n                        ROUTER_CONFIGURATION,\n                        [UrlHandlingStrategy, new Optional()],\n                        [RouteReuseStrategy, new Optional()]\n                    ]\n                },\n                {\n                    provide: LOCALIZE_ROUTER_FORROOT_GUARD,\n                    useFactory: provideForRootGuard,\n                    deps: [[LocalizeRouterModule, new Optional(), new SkipSelf()]]\n                },\n                { provide: USE_CACHED_LANG, useValue: config.useCachedLang },\n                { provide: ALWAYS_SET_PREFIX, useValue: config.alwaysSetPrefix },\n                { provide: CACHE_NAME, useValue: config.cacheName },\n                { provide: CACHE_MECHANISM, useValue: config.cacheMechanism },\n                { provide: DEFAULT_LANG_FUNCTION, useValue: config.defaultLangFunction },\n                { provide: COOKIE_FORMAT, useValue: config.cookieFormat },\n                { provide: INITIAL_NAVIGATION, useValue: config.initialNavigation },\n                LocalizeRouterSettings,\n                config.parser || { provide: LocalizeParser, useClass: DummyLocalizeParser },\n                {\n                    provide: RAW_ROUTES,\n                    multi: true,\n                    useValue: routes\n                },\n                LocalizeRouterService,\n                ParserInitializer,\n                {\n                    provide: APP_INITIALIZER,\n                    multi: true,\n                    useFactory: getAppInitializer,\n                    deps: [ParserInitializer, LocalizeParser, RAW_ROUTES]\n                },\n                {\n                    provide: RouteReuseStrategy,\n                    useClass: GilsdavReuseStrategy\n                }\n            ]\n        };\n    }\n    static forChild(routes) {\n        return {\n            ngModule: LocalizeRouterModule,\n            providers: [\n                {\n                    provide: RAW_ROUTES,\n                    multi: true,\n                    useValue: routes\n                }\n            ]\n        };\n    }\n}\nLocalizeRouterModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: \"12.0.0\", version: \"13.1.0\", ngImport: i0, type: LocalizeRouterModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });\nLocalizeRouterModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: \"12.0.0\", version: \"13.1.0\", ngImport: i0, type: LocalizeRouterModule, declarations: [LocalizeRouterPipe], imports: [CommonModule, RouterModule, TranslateModule], exports: [LocalizeRouterPipe] });\nLocalizeRouterModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: \"12.0.0\", version: \"13.1.0\", ngImport: i0, type: LocalizeRouterModule, imports: [[CommonModule, RouterModule, TranslateModule]] });\ni0.ɵɵngDeclareClassMetadata({ minVersion: \"12.0.0\", version: \"13.1.0\", ngImport: i0, type: LocalizeRouterModule, decorators: [{\n            type: NgModule,\n            args: [{\n                    imports: [CommonModule, RouterModule, TranslateModule],\n                    declarations: [LocalizeRouterPipe],\n                    exports: [LocalizeRouterPipe]\n                }]\n        }] });\nfunction provideForRootGuard(localizeRouterModule) {\n    if (localizeRouterModule) {\n        throw new Error(`LocalizeRouterModule.forRoot() called twice. Lazy loaded modules should use LocalizeRouterModule.forChild() instead.`);\n    }\n    return 'guarded';\n}\n\nclass LocalizeNgModuleFactory extends NgModuleFactory {\n    constructor(moduleType) {\n        super();\n        this.moduleType = moduleType;\n        this.create = (parentInjector) => {\n            const compiler = parentInjector.get(Compiler);\n            const localize = parentInjector.get(LocalizeParser);\n            const compiled = compiler.compileModuleAndAllComponentsSync(this.moduleType);\n            const moduleRef = compiled.ngModuleFactory.create(parentInjector);\n            const getMethod = moduleRef.injector.get.bind(moduleRef.injector);\n            moduleRef.injector['get'] = (token, notFoundValue) => {\n                const getResult = getMethod(token, notFoundValue);\n                if (token === ROUTES) {\n                    // translate lazy routes\n                    return localize.initChildRoutes([].concat(...getResult));\n                }\n                else {\n                    return getResult;\n                }\n            };\n            return moduleRef;\n        };\n    }\n}\nfunction translateModule(moduleType) {\n    return new LocalizeNgModuleFactory(moduleType);\n}\n\n/*\n * Public API Surface of ngx-translate-router\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ALWAYS_SET_PREFIX, CACHE_MECHANISM, CACHE_NAME, COOKIE_FORMAT, CacheMechanism, DEFAULT_LANG_FUNCTION, DummyLocalizeParser, GilsdavReuseStrategy, INITIAL_NAVIGATION, LOCALIZE_ROUTER_FORROOT_GUARD, LocalizeNgModuleFactory, LocalizeParser, LocalizeRouterModule, LocalizeRouterPipe, LocalizeRouterService, LocalizeRouterSettings, LocalizedRouter, ManualParserLoader, ParserInitializer, RAW_ROUTES, USE_CACHED_LANG, getAppInitializer, provideForRootGuard, setupRouter, translateModule, wrapIntoObservable };\n"]},"metadata":{},"sourceType":"module"}